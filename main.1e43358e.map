{"version":3,"sources":["node_modules/stickyfilljs/dist/stickyfill.js","src/utils/index.js","src/utils/load-article.js","src/main.js"],"names":["wait","time","Promise","resolve","setTimeout","throwError","err","Error","$","document","querySelector","bind","$$","selector","querySelectorAll","debounce","fn","timeout","args","later","apply","clearTimeout","shrugMappings","Map","shrug","name","has","console","log","get","delete","updateHash","hash","history","replaceState","title","queue","articles","map","element","index","id","path","inViewport","findArticle","target","find","insertToDom","article","fromObserver","all","fetch","then","response","text","html","getAttribute","innerHTML","Stickyfill","addOne","setAttribute","loadArticleIfNeeded","options","isLoaded","startScrollObserver","handleIntersection","entries","forEach","entry","isIntersecting","visibleArticle","location","rootMargin","articleObserver","IntersectionObserver","observe","loadArticle","targetArticle","articlesToLoad","filter","_","error","init","deviceSupportsTouch","Boolean","window","navigator","maxTouchPoints","msMaxTouchPoints","DocumentTouch","body","classList","add","updateWindowHeight","vh","innerHeight","documentElement","style","setProperty","addEventListener","splash","main","scrollIntoView","behavior","block","targetId","slice","remove","refreshAll","getElementById"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","file":"main.1e43358e.map","sourceRoot":"..","sourcesContent":["/*!\r\n  * Stickyfill – `position: sticky` polyfill\r\n  * v. 2.1.0 | https://github.com/wilddeer/stickyfill\r\n  * MIT License\r\n  */\r\n\r\n;(function(window, document) {\r\n    'use strict';\r\n    \r\n    /*\r\n     * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.\r\n     *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features\r\n     *    of the polyfill, but the API will remain functional to avoid breaking things.\r\n     */\r\n    \r\n    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n    \r\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n    \r\n    var seppuku = false;\r\n    \r\n    var isWindowDefined = typeof window !== 'undefined';\r\n    \r\n    // The polyfill can’t function properly without `window` or `window.getComputedStyle`.\r\n    if (!isWindowDefined || !window.getComputedStyle) seppuku = true;\r\n    // Dont’t get in a way if the browser supports `position: sticky` natively.\r\n    else {\r\n            (function () {\r\n                var testNode = document.createElement('div');\r\n    \r\n                if (['', '-webkit-', '-moz-', '-ms-'].some(function (prefix) {\r\n                    try {\r\n                        testNode.style.position = prefix + 'sticky';\r\n                    } catch (e) {}\r\n    \r\n                    return testNode.style.position != '';\r\n                })) seppuku = true;\r\n            })();\r\n        }\r\n    \r\n    /*\r\n     * 2. “Global” vars used across the polyfill\r\n     */\r\n    var isInitialized = false;\r\n    \r\n    // Check if Shadow Root constructor exists to make further checks simpler\r\n    var shadowRootExists = typeof ShadowRoot !== 'undefined';\r\n    \r\n    // Last saved scroll position\r\n    var scroll = {\r\n        top: null,\r\n        left: null\r\n    };\r\n    \r\n    // Array of created Sticky instances\r\n    var stickies = [];\r\n    \r\n    /*\r\n     * 3. Utility functions\r\n     */\r\n    function extend(targetObj, sourceObject) {\r\n        for (var key in sourceObject) {\r\n            if (sourceObject.hasOwnProperty(key)) {\r\n                targetObj[key] = sourceObject[key];\r\n            }\r\n        }\r\n    }\r\n    \r\n    function parseNumeric(val) {\r\n        return parseFloat(val) || 0;\r\n    }\r\n    \r\n    function getDocOffsetTop(node) {\r\n        var docOffsetTop = 0;\r\n    \r\n        while (node) {\r\n            docOffsetTop += node.offsetTop;\r\n            node = node.offsetParent;\r\n        }\r\n    \r\n        return docOffsetTop;\r\n    }\r\n    \r\n    /*\r\n     * 4. Sticky class\r\n     */\r\n    \r\n    var Sticky = function () {\r\n        function Sticky(node) {\r\n            _classCallCheck(this, Sticky);\r\n    \r\n            if (!(node instanceof HTMLElement)) throw new Error('First argument must be HTMLElement');\r\n            if (stickies.some(function (sticky) {\r\n                return sticky._node === node;\r\n            })) throw new Error('Stickyfill is already applied to this node');\r\n    \r\n            this._node = node;\r\n            this._stickyMode = null;\r\n            this._active = false;\r\n    \r\n            stickies.push(this);\r\n    \r\n            this.refresh();\r\n        }\r\n    \r\n        _createClass(Sticky, [{\r\n            key: 'refresh',\r\n            value: function refresh() {\r\n                if (seppuku || this._removed) return;\r\n                if (this._active) this._deactivate();\r\n    \r\n                var node = this._node;\r\n    \r\n                /*\r\n                 * 1. Save node computed props\r\n                 */\r\n                var nodeComputedStyle = getComputedStyle(node);\r\n                var nodeComputedProps = {\r\n                    position: nodeComputedStyle.position,\r\n                    top: nodeComputedStyle.top,\r\n                    display: nodeComputedStyle.display,\r\n                    marginTop: nodeComputedStyle.marginTop,\r\n                    marginBottom: nodeComputedStyle.marginBottom,\r\n                    marginLeft: nodeComputedStyle.marginLeft,\r\n                    marginRight: nodeComputedStyle.marginRight,\r\n                    cssFloat: nodeComputedStyle.cssFloat\r\n                };\r\n    \r\n                /*\r\n                 * 2. Check if the node can be activated\r\n                 */\r\n                if (isNaN(parseFloat(nodeComputedProps.top)) || nodeComputedProps.display == 'table-cell' || nodeComputedProps.display == 'none') return;\r\n    \r\n                this._active = true;\r\n    \r\n                /*\r\n                 * 3. Check if the current node position is `sticky`. If it is, it means that the browser supports sticky positioning,\r\n                 *    but the polyfill was force-enabled. We set the node’s position to `static` before continuing, so that the node\r\n                 *    is in it’s initial position when we gather its params.\r\n                 */\r\n                var originalPosition = node.style.position;\r\n                if (nodeComputedStyle.position == 'sticky' || nodeComputedStyle.position == '-webkit-sticky') node.style.position = 'static';\r\n    \r\n                /*\r\n                 * 4. Get necessary node parameters\r\n                 */\r\n                var referenceNode = node.parentNode;\r\n                var parentNode = shadowRootExists && referenceNode instanceof ShadowRoot ? referenceNode.host : referenceNode;\r\n                var nodeWinOffset = node.getBoundingClientRect();\r\n                var parentWinOffset = parentNode.getBoundingClientRect();\r\n                var parentComputedStyle = getComputedStyle(parentNode);\r\n    \r\n                this._parent = {\r\n                    node: parentNode,\r\n                    styles: {\r\n                        position: parentNode.style.position\r\n                    },\r\n                    offsetHeight: parentNode.offsetHeight\r\n                };\r\n                this._offsetToWindow = {\r\n                    left: nodeWinOffset.left,\r\n                    right: document.documentElement.clientWidth - nodeWinOffset.right\r\n                };\r\n                this._offsetToParent = {\r\n                    top: nodeWinOffset.top - parentWinOffset.top - parseNumeric(parentComputedStyle.borderTopWidth),\r\n                    left: nodeWinOffset.left - parentWinOffset.left - parseNumeric(parentComputedStyle.borderLeftWidth),\r\n                    right: -nodeWinOffset.right + parentWinOffset.right - parseNumeric(parentComputedStyle.borderRightWidth)\r\n                };\r\n                this._styles = {\r\n                    position: originalPosition,\r\n                    top: node.style.top,\r\n                    bottom: node.style.bottom,\r\n                    left: node.style.left,\r\n                    right: node.style.right,\r\n                    width: node.style.width,\r\n                    marginTop: node.style.marginTop,\r\n                    marginLeft: node.style.marginLeft,\r\n                    marginRight: node.style.marginRight\r\n                };\r\n    \r\n                var nodeTopValue = parseNumeric(nodeComputedProps.top);\r\n                this._limits = {\r\n                    start: nodeWinOffset.top + window.pageYOffset - nodeTopValue,\r\n                    end: parentWinOffset.top + window.pageYOffset + parentNode.offsetHeight - parseNumeric(parentComputedStyle.borderBottomWidth) - node.offsetHeight - nodeTopValue - parseNumeric(nodeComputedProps.marginBottom)\r\n                };\r\n    \r\n                /*\r\n                 * 5. Ensure that the node will be positioned relatively to the parent node\r\n                 */\r\n                var parentPosition = parentComputedStyle.position;\r\n    \r\n                if (parentPosition != 'absolute' && parentPosition != 'relative') {\r\n                    parentNode.style.position = 'relative';\r\n                }\r\n    \r\n                /*\r\n                 * 6. Recalc node position.\r\n                 *    It’s important to do this before clone injection to avoid scrolling bug in Chrome.\r\n                 */\r\n                this._recalcPosition();\r\n    \r\n                /*\r\n                 * 7. Create a clone\r\n                 */\r\n                var clone = this._clone = {};\r\n                clone.node = document.createElement('div');\r\n    \r\n                // Apply styles to the clone\r\n                extend(clone.node.style, {\r\n                    width: nodeWinOffset.right - nodeWinOffset.left + 'px',\r\n                    height: nodeWinOffset.bottom - nodeWinOffset.top + 'px',\r\n                    marginTop: nodeComputedProps.marginTop,\r\n                    marginBottom: nodeComputedProps.marginBottom,\r\n                    marginLeft: nodeComputedProps.marginLeft,\r\n                    marginRight: nodeComputedProps.marginRight,\r\n                    cssFloat: nodeComputedProps.cssFloat,\r\n                    padding: 0,\r\n                    border: 0,\r\n                    borderSpacing: 0,\r\n                    fontSize: '1em',\r\n                    position: 'static'\r\n                });\r\n    \r\n                referenceNode.insertBefore(clone.node, node);\r\n                clone.docOffsetTop = getDocOffsetTop(clone.node);\r\n            }\r\n        }, {\r\n            key: '_recalcPosition',\r\n            value: function _recalcPosition() {\r\n                if (!this._active || this._removed) return;\r\n    \r\n                var stickyMode = scroll.top <= this._limits.start ? 'start' : scroll.top >= this._limits.end ? 'end' : 'middle';\r\n    \r\n                if (this._stickyMode == stickyMode) return;\r\n    \r\n                switch (stickyMode) {\r\n                    case 'start':\r\n                        extend(this._node.style, {\r\n                            position: 'absolute',\r\n                            left: this._offsetToParent.left + 'px',\r\n                            right: this._offsetToParent.right + 'px',\r\n                            top: this._offsetToParent.top + 'px',\r\n                            bottom: 'auto',\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0,\r\n                            marginTop: 0\r\n                        });\r\n                        break;\r\n    \r\n                    case 'middle':\r\n                        extend(this._node.style, {\r\n                            position: 'fixed',\r\n                            left: this._offsetToWindow.left + 'px',\r\n                            right: this._offsetToWindow.right + 'px',\r\n                            top: this._styles.top,\r\n                            bottom: 'auto',\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0,\r\n                            marginTop: 0\r\n                        });\r\n                        break;\r\n    \r\n                    case 'end':\r\n                        extend(this._node.style, {\r\n                            position: 'absolute',\r\n                            left: this._offsetToParent.left + 'px',\r\n                            right: this._offsetToParent.right + 'px',\r\n                            top: 'auto',\r\n                            bottom: 0,\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0\r\n                        });\r\n                        break;\r\n                }\r\n    \r\n                this._stickyMode = stickyMode;\r\n            }\r\n        }, {\r\n            key: '_fastCheck',\r\n            value: function _fastCheck() {\r\n                if (!this._active || this._removed) return;\r\n    \r\n                if (Math.abs(getDocOffsetTop(this._clone.node) - this._clone.docOffsetTop) > 1 || Math.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1) this.refresh();\r\n            }\r\n        }, {\r\n            key: '_deactivate',\r\n            value: function _deactivate() {\r\n                var _this = this;\r\n    \r\n                if (!this._active || this._removed) return;\r\n    \r\n                this._clone.node.parentNode.removeChild(this._clone.node);\r\n                delete this._clone;\r\n    \r\n                extend(this._node.style, this._styles);\r\n                delete this._styles;\r\n    \r\n                // Check whether element’s parent node is used by other stickies.\r\n                // If not, restore parent node’s styles.\r\n                if (!stickies.some(function (sticky) {\r\n                    return sticky !== _this && sticky._parent && sticky._parent.node === _this._parent.node;\r\n                })) {\r\n                    extend(this._parent.node.style, this._parent.styles);\r\n                }\r\n                delete this._parent;\r\n    \r\n                this._stickyMode = null;\r\n                this._active = false;\r\n    \r\n                delete this._offsetToWindow;\r\n                delete this._offsetToParent;\r\n                delete this._limits;\r\n            }\r\n        }, {\r\n            key: 'remove',\r\n            value: function remove() {\r\n                var _this2 = this;\r\n    \r\n                this._deactivate();\r\n    \r\n                stickies.some(function (sticky, index) {\r\n                    if (sticky._node === _this2._node) {\r\n                        stickies.splice(index, 1);\r\n                        return true;\r\n                    }\r\n                });\r\n    \r\n                this._removed = true;\r\n            }\r\n        }]);\r\n    \r\n        return Sticky;\r\n    }();\r\n    \r\n    /*\r\n     * 5. Stickyfill API\r\n     */\r\n    \r\n    \r\n    var Stickyfill = {\r\n        stickies: stickies,\r\n        Sticky: Sticky,\r\n    \r\n        forceSticky: function forceSticky() {\r\n            seppuku = false;\r\n            init();\r\n    \r\n            this.refreshAll();\r\n        },\r\n        addOne: function addOne(node) {\r\n            // Check whether it’s a node\r\n            if (!(node instanceof HTMLElement)) {\r\n                // Maybe it’s a node list of some sort?\r\n                // Take first node from the list then\r\n                if (node.length && node[0]) node = node[0];else return;\r\n            }\r\n    \r\n            // Check if Stickyfill is already applied to the node\r\n            // and return existing sticky\r\n            for (var i = 0; i < stickies.length; i++) {\r\n                if (stickies[i]._node === node) return stickies[i];\r\n            }\r\n    \r\n            // Create and return new sticky\r\n            return new Sticky(node);\r\n        },\r\n        add: function add(nodeList) {\r\n            // If it’s a node make an array of one node\r\n            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n            // Check if the argument is an iterable of some sort\r\n            if (!nodeList.length) return;\r\n    \r\n            // Add every element as a sticky and return an array of created Sticky instances\r\n            var addedStickies = [];\r\n    \r\n            var _loop = function _loop(i) {\r\n                var node = nodeList[i];\r\n    \r\n                // If it’s not an HTMLElement – create an empty element to preserve 1-to-1\r\n                // correlation with input list\r\n                if (!(node instanceof HTMLElement)) {\r\n                    addedStickies.push(void 0);\r\n                    return 'continue';\r\n                }\r\n    \r\n                // If Stickyfill is already applied to the node\r\n                // add existing sticky\r\n                if (stickies.some(function (sticky) {\r\n                    if (sticky._node === node) {\r\n                        addedStickies.push(sticky);\r\n                        return true;\r\n                    }\r\n                })) return 'continue';\r\n    \r\n                // Create and add new sticky\r\n                addedStickies.push(new Sticky(node));\r\n            };\r\n    \r\n            for (var i = 0; i < nodeList.length; i++) {\r\n                var _ret2 = _loop(i);\r\n    \r\n                if (_ret2 === 'continue') continue;\r\n            }\r\n    \r\n            return addedStickies;\r\n        },\r\n        refreshAll: function refreshAll() {\r\n            stickies.forEach(function (sticky) {\r\n                return sticky.refresh();\r\n            });\r\n        },\r\n        removeOne: function removeOne(node) {\r\n            // Check whether it’s a node\r\n            if (!(node instanceof HTMLElement)) {\r\n                // Maybe it’s a node list of some sort?\r\n                // Take first node from the list then\r\n                if (node.length && node[0]) node = node[0];else return;\r\n            }\r\n    \r\n            // Remove the stickies bound to the nodes in the list\r\n            stickies.some(function (sticky) {\r\n                if (sticky._node === node) {\r\n                    sticky.remove();\r\n                    return true;\r\n                }\r\n            });\r\n        },\r\n        remove: function remove(nodeList) {\r\n            // If it’s a node make an array of one node\r\n            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n            // Check if the argument is an iterable of some sort\r\n            if (!nodeList.length) return;\r\n    \r\n            // Remove the stickies bound to the nodes in the list\r\n    \r\n            var _loop2 = function _loop2(i) {\r\n                var node = nodeList[i];\r\n    \r\n                stickies.some(function (sticky) {\r\n                    if (sticky._node === node) {\r\n                        sticky.remove();\r\n                        return true;\r\n                    }\r\n                });\r\n            };\r\n    \r\n            for (var i = 0; i < nodeList.length; i++) {\r\n                _loop2(i);\r\n            }\r\n        },\r\n        removeAll: function removeAll() {\r\n            while (stickies.length) {\r\n                stickies[0].remove();\r\n            }\r\n        }\r\n    };\r\n    \r\n    /*\r\n     * 6. Setup events (unless the polyfill was disabled)\r\n     */\r\n    function init() {\r\n        if (isInitialized) {\r\n            return;\r\n        }\r\n    \r\n        isInitialized = true;\r\n    \r\n        // Watch for scroll position changes and trigger recalc/refresh if needed\r\n        function checkScroll() {\r\n            if (window.pageXOffset != scroll.left) {\r\n                scroll.top = window.pageYOffset;\r\n                scroll.left = window.pageXOffset;\r\n    \r\n                Stickyfill.refreshAll();\r\n            } else if (window.pageYOffset != scroll.top) {\r\n                scroll.top = window.pageYOffset;\r\n                scroll.left = window.pageXOffset;\r\n    \r\n                // recalc position for all stickies\r\n                stickies.forEach(function (sticky) {\r\n                    return sticky._recalcPosition();\r\n                });\r\n            }\r\n        }\r\n    \r\n        checkScroll();\r\n        window.addEventListener('scroll', checkScroll);\r\n    \r\n        // Watch for window resizes and device orientation changes and trigger refresh\r\n        window.addEventListener('resize', Stickyfill.refreshAll);\r\n        window.addEventListener('orientationchange', Stickyfill.refreshAll);\r\n    \r\n        //Fast dirty check for layout changes every 500ms\r\n        var fastCheckTimer = void 0;\r\n    \r\n        function startFastCheckTimer() {\r\n            fastCheckTimer = setInterval(function () {\r\n                stickies.forEach(function (sticky) {\r\n                    return sticky._fastCheck();\r\n                });\r\n            }, 500);\r\n        }\r\n    \r\n        function stopFastCheckTimer() {\r\n            clearInterval(fastCheckTimer);\r\n        }\r\n    \r\n        var docHiddenKey = void 0;\r\n        var visibilityChangeEventName = void 0;\r\n    \r\n        if ('hidden' in document) {\r\n            docHiddenKey = 'hidden';\r\n            visibilityChangeEventName = 'visibilitychange';\r\n        } else if ('webkitHidden' in document) {\r\n            docHiddenKey = 'webkitHidden';\r\n            visibilityChangeEventName = 'webkitvisibilitychange';\r\n        }\r\n    \r\n        if (visibilityChangeEventName) {\r\n            if (!document[docHiddenKey]) startFastCheckTimer();\r\n    \r\n            document.addEventListener(visibilityChangeEventName, function () {\r\n                if (document[docHiddenKey]) {\r\n                    stopFastCheckTimer();\r\n                } else {\r\n                    startFastCheckTimer();\r\n                }\r\n            });\r\n        } else startFastCheckTimer();\r\n    }\r\n    \r\n    if (!seppuku) init();\r\n    \r\n    /*\r\n     * 7. Expose Stickyfill\r\n     */\r\n    if (typeof module != 'undefined' && module.exports) {\r\n        module.exports = Stickyfill;\r\n    } else if (isWindowDefined) {\r\n        window.Stickyfill = Stickyfill;\r\n    }\r\n    \r\n})(window, document);","/**\r\n * Returned eine Promise, die sich nach gegebener Zeit selbst erfüllt\r\n * @param {number} time Zeit, bis Promise resolved\r\n */\r\nexport const wait = time => new Promise(resolve => setTimeout(resolve, time));\r\n\r\n/**\r\n * Nimmt Error Message und wirft einen Fehler\r\n * @param {string} err Fehlermeldung\r\n */\r\nexport const throwError = err => {\r\n  throw Error(err);\r\n};\r\n\r\n/**\r\n * Alias zu querySelector(), nimmt CSS Selektor, liefert HTML Element oder null\r\n * @type {Function}\r\n * @param {string} selector CSS3 Selektor\r\n * @returns {HTMLElement|null} Element oder Array aus Elementen\r\n */\r\nexport const $ = document.querySelector.bind(document);\r\n/**\r\n * Wrapper um querySelectorAll(), liefert Array statt NodeList\r\n * @param {string} selector CSS3 Selektor\r\n * @returns {Array<HTMLElement>} Array aus gefundenen Elementen\r\n */\r\nexport const $$ = selector => [...document.querySelectorAll(selector)];\r\n\r\n/**\r\n * Führt eine Funktion erst aus, wenn sie eine Zeit lang nicht ausgeführt wurde\r\n * @param {Function} fn Funktion, die debounced werden soll\r\n * @param {number} wait Zeit, die vergangen sein muss bevor fn ausgeführt wird\r\n */\r\nexport const debounce = (fn, wait = 0) => {\r\n  let timeout;\r\n\r\n  return function(...args) {\r\n    const later = () => {\r\n      timeout = null;\r\n      fn.apply(this, args);\r\n    };\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n  };\r\n};\r\n\r\nconst shrugMappings = new Map([\r\n  // Artikel:\r\n  ['zwischen-seemannsgarn-und-strandgut', `🍺 Kneipentour, for science.`],\r\n  ['bringt-farbe-in-die-stadt', `⚽ Abenteuer in den Graffitiburgen.`],\r\n  ['film-ab-bheaven', `🛰 Doch gab es die Mondlandung wirklich?`],\r\n  ['back-to-print', `🍪 Aber Print hat keine Cookies.`],\r\n  ['projekt-antarktis', `🐧 Pengwings.`],\r\n  [\r\n    'wie-ki-die-designwelt-aendert',\r\n    `🔴 I'm afraid I can't let you do that, Dave.`,\r\n  ],\r\n  // Team\r\n  ['jonas', '✔ Perfekt, trotz Serifen.'],\r\n  ['max', '✔ Ist Photoshop, nicht Paint.'],\r\n]);\r\n\r\nexport const shrug = name => {\r\n  if (!shrugMappings.has(name)) return;\r\n\r\n  console.log(`\\n${shrugMappings.get(name)}`);\r\n  shrugMappings.delete(name);\r\n};\r\n\r\nexport const updateHash = debounce(hash => {\r\n  if (history.replaceState) {\r\n    shrug(hash);\r\n    history.replaceState(null, document.title, `#${hash}`);\r\n  }\r\n}, 500);\r\n","import { $$, wait, updateHash } from './';\r\nimport Stickyfill from 'stickyfilljs';\r\nlet queue = Promise.resolve();\r\n\r\n// Array, mit einem Objekt für jeden Artikel\r\nconst articles = $$('.article').map((element, index) => ({\r\n  element,\r\n  index,\r\n  name: element.id,\r\n  path: `./articles/${element.id}.html`,\r\n  inViewport: false,\r\n}));\r\n\r\n// Liefert Artikel-Objekt anhand von Index oder Artikelname\r\nconst findArticle = target => {\r\n  return typeof target === 'number'\r\n    ? articles[target]\r\n    : articles.find(({ name }) => name === target);\r\n};\r\n\r\nconst insertToDom = async (article, { fromObserver } = {}) => {\r\n  const { path, element } = article;\r\n\r\n  // Warten bis HTML des Artikels abgerufen und ggf. Wartezeit vorbei ist\r\n  const [html] = await Promise.all([\r\n    fetch(path).then(response => response.text()),\r\n    fromObserver && wait(1200),\r\n  ]);\r\n\r\n  // Artikel inzwischen schon (parallel) fertig geladen? Abbrechen\r\n  if (element.getAttribute('data-loaded') === 'true') return;\r\n\r\n  // Artikel in DOM einfügen\r\n  element.innerHTML = html;\r\n\r\n  // Neu hinzugefügte Artikel-Nummer polyfillen\r\n  Stickyfill.addOne(element.querySelectorAll('.stickyfill'));\r\n\r\n  // Als geladen markieren\r\n  element.setAttribute('data-loaded', true);\r\n\r\n  return;\r\n};\r\n\r\nconst loadArticleIfNeeded = (article, options = {}) => {\r\n  // Schon geladen: Sofort returnen, nothing to do here...\r\n  const isLoaded = article.element.getAttribute('data-loaded') === 'true';\r\n  if (isLoaded) return;\r\n\r\n  // Laden durch Observer: Warten bis Laden früherer Artikel (queue) fertig,\r\n  // dann laden, falls Artikel immer noch im Viewport ist\r\n  // -> stoppt gleichzeitiges Laden mehrerer Artikel bei zu schnellem Scrollen\r\n  if (options.fromObserver) {\r\n    return (queue = queue.then(() => {\r\n      // wird erst ausgeführt, nachdem alle anderen Funktionen,\r\n      // die per queue = queue.then() angehängt wurden, beendet sind\r\n      article.inViewport && insertToDom(article, options);\r\n    }));\r\n  }\r\n\r\n  // Laden nicht von Observer angefordert: Sofort starten\r\n  return insertToDom(article);\r\n};\r\n\r\nfunction startScrollObserver() {\r\n  // Artikel laden, falls Observer eine Veränderung meldet & Artikel sichtbar\r\n  const handleIntersection = entries => {\r\n    entries.forEach(entry => {\r\n      const article = findArticle(entry.target.id);\r\n      article.inViewport = entry.isIntersecting;\r\n\r\n      if (article.inViewport) {\r\n        // Hash updaten, damit URL direkt auf Artikel verweist\r\n        updateHash(article.name);\r\n        loadArticleIfNeeded(article, { fromObserver: true });\r\n      } else {\r\n        const visibleArticle = articles.find(({ inViewport }) => inViewport);\r\n        // Kein einziger Artikel sichtbar, aber aktuell ein Hash gesetzt? Reset\r\n        // Ansonsten: Hash auf (noch) sichtbaren Artikel aktualisieren\r\n        if (!visibleArticle) location.hash && updateHash('');\r\n        else updateHash(visibleArticle.name);\r\n      }\r\n    });\r\n  };\r\n\r\n  // Beobachtet jeden Artikel im articles array auf Sichtbarkeitsänderungen\r\n  const options = { rootMargin: '-1px 0px' };\r\n  const articleObserver = new IntersectionObserver(handleIntersection, options);\r\n  articles.forEach(({ element }) => articleObserver.observe(element));\r\n}\r\n\r\nasync function loadArticle(target) {\r\n  const targetArticle = findArticle(target);\r\n  if (!targetArticle) return;\r\n\r\n  // Artikel + alle Artikel oberhalb (index kleiner/gleich Zielartikel) laden\r\n  const articlesToLoad = articles\r\n    .filter((_, index) => index <= targetArticle.index)\r\n    .map(loadArticleIfNeeded);\r\n\r\n  try {\r\n    // Warten, bis alle Artikel geladen sind\r\n    await Promise.all(articlesToLoad);\r\n  } catch (error) {\r\n    return console.error(\r\n      `Fehler beim Laden des Artikels ${targetArticle.name}: ${error}`,\r\n    );\r\n  }\r\n\r\n  return targetArticle;\r\n}\r\n\r\nexport { startScrollObserver, loadArticle };\r\nexport default loadArticle;\r\n","import Stickyfill from 'stickyfilljs';\r\n\r\nimport { $, debounce } from './utils';\r\nimport { startScrollObserver, loadArticle } from './utils/load-article';\r\n\r\nasync function init() {\r\n  // Prüfen, ob Gerät ein Touch-Interface hat\r\n  const deviceSupportsTouch = Boolean(\r\n    'ontouchstart' in window ||\r\n      window.navigator.maxTouchPoints > 0 ||\r\n      window.navigator.msMaxTouchPoints > 0 ||\r\n      (window.DocumentTouch && document instanceof DocumentTouch),\r\n  );\r\n  if (deviceSupportsTouch) document.body.classList.add('supports-touch');\r\n\r\n  // Mobile Viewport-Größe manuell berechnen, vgl.:\r\n  // https://css-tricks.com/the-trick-to-viewport-units-on-mobile/\r\n  const updateWindowHeight = () => {\r\n    const vh = window.innerHeight * 0.01;\r\n    document.documentElement.style.setProperty('--vh', `${vh}px`);\r\n  };\r\n  updateWindowHeight();\r\n  window.addEventListener('resize', debounce(updateWindowHeight, 500));\r\n\r\n  // HTML Elemente\r\n  const splash = $('.js-splash');\r\n  const main = $('.js-main');\r\n\r\n  // Bei Klick auf Splashscreen zu Content scrollen\r\n  splash.addEventListener('click', () => {\r\n    main.scrollIntoView({ behavior: 'smooth', block: 'start' });\r\n  });\r\n\r\n  const { hash } = window.location;\r\n  const targetId = hash.slice(1);\r\n  const targetArticle = await loadArticle(targetId);\r\n  if (!targetArticle) await loadArticle(0);\r\n\r\n  document.body.classList.remove('empty');\r\n  startScrollObserver();\r\n  Stickyfill.refreshAll();\r\n\r\n  if (targetArticle) {\r\n    targetArticle.element.scrollIntoView({\r\n      behavior: 'smooth',\r\n      block: 'start',\r\n    });\r\n  }\r\n\r\n  window.addEventListener('hashchange', async () => {\r\n    const { hash } = window.location;\r\n    const targetId = hash.slice(1);\r\n    const target = document.getElementById(targetId);\r\n    if (target && target.getAttribute('data-loaded') === 'false') {\r\n      const article = await loadArticle(window.location.hash.slice(1));\r\n      if (!article) return;\r\n      article.element.scrollIntoView({ behavior: 'smooth', block: 'start' });\r\n    }\r\n  });\r\n}\r\n\r\n// Go!\r\nsetTimeout(init, 0);\r\n"]}