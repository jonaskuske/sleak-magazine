{"version":3,"sources":["src/utils/index.js","src/utils/load-article.js","src/main.js"],"names":["wait","time","Promise","resolve","setTimeout","throwError","err","Error","$","document","querySelector","bind","$$","selector","querySelectorAll","debounce","fn","timeout","args","clearTimeout","apply","isCrawler","test","navigator","userAgent","specialMessages","Map","logSpecialMessage","name","has","console","log","get","delete","updateHash","hash","title","history","replaceState","loadArticle","queue","articles","map","element","index","id","path","inViewport","findArticle","target","find","insertToDom","article","fromObserver","all","fetch","then","response","text","html","getAttribute","innerHTML","window","Stickyfill","addOne","setAttribute","loadArticleIfNeeded","options","isLoaded","startScrollObserver","handleIntersection","articleObserver","IntersectionObserver","entries","forEach","entry","isIntersecting","titleEl","textContent","visibleArticle","rootMargin","observe","targetArticle","articlesToLoad","filter","_","error","init","Boolean","maxTouchPoints","msMaxTouchPoints","DocumentTouch","body","classList","add","updateWindowHeight","vh","innerHeight","documentElement","style","setProperty","addEventListener","splash","main","scrollIntoView","behavior","block","location","targetId","slice","length","remove","refreshAll","getElementById","onload"],"mappings":"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","file":"main.3205a39d.js","sourceRoot":"..","sourcesContent":["/**\r\n * Returns a Promise which resolves after a given time\r\n * @param {number} time Time until Promise resolves\r\n */\r\nexport const wait = time => new Promise(resolve => setTimeout(resolve, time));\r\n\r\n/**\r\n * Throws an error with a given error message\r\n * @param {string} err The error message\r\n */\r\nexport const throwError = err => {\r\n  throw Error(err);\r\n};\r\n\r\n/**\r\n * Alias for querySelector(), takes CSS selector and returns HTMLElement or null\r\n * @type {Function}\r\n * @param {string} selector CSS3 Selektor\r\n * @returns {HTMLElement|null} The found HTMLElement (null if there's no match)\r\n */\r\nexport const $ = document.querySelector.bind(document);\r\n/**\r\n * Wrapper for querySelectorAll(), returns Array instead of NodeList\r\n * @param {string} selector CSS3 Selector\r\n * @returns {Array<HTMLElement>} Array of found elements\r\n */\r\nexport const $$ = selector => [...document.querySelectorAll(selector)];\r\n\r\n/**\r\n * Executes a given function only after it wasn't called again for some time\r\n * @param {Function} fn function that should be debounced\r\n * @param {number} wait time that has to pass until fn is called\r\n */\r\nexport const debounce = (fn, wait = 0) => {\r\n  let timeout;\r\n\r\n  return function(...args) {\r\n    const later = () => {\r\n      timeout = null;\r\n      fn.apply(this, args);\r\n    };\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n  };\r\n};\r\n\r\nexport const isCrawler = /bot|googlebot|crawler|spider|robot|crawling/i.test(\r\n  navigator.userAgent,\r\n);\r\n\r\n/* --- Easteregg-ish stuff --- */\r\nconst specialMessages = new Map([\r\n  // Articles\r\n  ['zwischen-seemannsgarn-und-strandgut', `🍺 Kneipentour, for science.`],\r\n  ['bringt-farbe-in-die-stadt', `⚽ Abenteuer in den Graffitiburgen.`],\r\n  ['film-ab-bheaven', `🛰 Doch gab es die Mondlandung wirklich?`],\r\n  ['back-to-print', `🍪 Aber Print hat keine Cookies.`],\r\n  ['projekt-antarktis', `🐧 Pengwings.`],\r\n  [\r\n    'wie-ki-die-designwelt-aendert',\r\n    `🔴 I'm afraid I can't let you do that, Dave.`,\r\n  ],\r\n  // Team\r\n  ['jonas', '✔ Perfekt, trotz Serifen.'],\r\n  ['max', '✔ Ist Photoshop, nicht Paint.'],\r\n]);\r\n\r\nconst logSpecialMessage = name => {\r\n  if (!specialMessages.has(name)) return;\r\n\r\n  console.log(`\\n${specialMessages.get(name)}`);\r\n  // Delete, so messages are only logged once\r\n  specialMessages.delete(name);\r\n};\r\n/* --- --- */\r\n\r\n/**\r\n * Updates URL hash without triggering hashchange by using history.replaceState\r\n * Debounced, so updates can only happen every 500ms\r\n * @param {string} hash The hash (without the leading #)\r\n * @param {string?} title (optional) new document.title\r\n */\r\nexport const updateHash = debounce((hash, title) => {\r\n  if (history.replaceState) {\r\n    logSpecialMessage(hash);\r\n    history.replaceState(null, document.title, `#${hash}`);\r\n  }\r\n  if (title) document.title = title;\r\n}, 500);\r\n","import { $$, wait, updateHash } from './';\r\nlet queue = Promise.resolve();\r\n\r\n// Array, containing an Object with the HTML node and metadata for every article\r\nconst articles = $$('.article').map((element, index) => ({\r\n  element,\r\n  index,\r\n  name: element.id,\r\n  title: false, // Set once article is scrolled into view\r\n  path: `./articles/${element.id}.html`,\r\n  inViewport: false,\r\n}));\r\n\r\n// Returns the article Object based on index or the article name\r\nconst findArticle = target => {\r\n  return typeof target === 'number'\r\n    ? articles[target]\r\n    : articles.find(({ name }) => name === target);\r\n};\r\n\r\n/**\r\n * Fetches an articles HTML and inserts it into its DOM node\r\n * @param {boolean} article The article to load\r\n * @param {{fromObserver: boolean}} options Whether load was triggered by scroll\r\n */\r\nconst insertToDom = async (article, { fromObserver } = {}) => {\r\n  const { path, element } = article;\r\n\r\n  // Wait until article HTML is fetched and mandatory loading time has passed\r\n  // (if loading was triggered by scrolling)\r\n  const [html] = await Promise.all([\r\n    fetch(path).then(response => response.text()),\r\n    fromObserver && wait(1200),\r\n  ]);\r\n\r\n  // Artikel has been loaded in the mean time? Abort\r\n  if (element.getAttribute('data-loaded') === 'true') return;\r\n\r\n  // Insert article in DOM\r\n  element.innerHTML = html;\r\n\r\n  // Add newly added article number to position-sticky polyfill\r\n  // ! method on window supplied by utils/polyfills.js\r\n  window.Stickyfill.addOne(element.querySelectorAll('.stickyfill'));\r\n\r\n  // Mark article as loaded\r\n  element.setAttribute('data-loaded', true);\r\n\r\n  return;\r\n};\r\n\r\n/**\r\n * Loads an article only if needed: if it has been loaded already, it aborts.\r\n * If the loading is requested from the IntersectionObserver (due to scrolling),\r\n * it waits until previous articles have been fully loaded and only loads,\r\n * if the requested article is still visible.\r\n *\r\n * This prevents multiple articles being loaded due to the user scrolling fast.\r\n * @param {Object} article The article to load\r\n * @param {{fromObserver: boolean}} options Whether load was triggered by scroll\r\n */\r\nconst loadArticleIfNeeded = (article, options = {}) => {\r\n  // Already loaded: Return immediately, nothing to do here...\r\n  const isLoaded = article.element.getAttribute('data-loaded') === 'true';\r\n  if (isLoaded) return Promise.resolve();\r\n\r\n  // Loading from observer: Wait until previous articles (queue) are loaded,\r\n  // then load, if article is still in viewport\r\n  // -> prevents simultaneous load of multiple articles due to too-fast scroll\r\n  if (options.fromObserver) {\r\n    return (queue = queue.then(() => {\r\n      // will only be run after all other function chained using\r\n      // queue = queue.then() are done\r\n      if (article.inViewport) return insertToDom(article, options);\r\n      else return Promise.resolve();\r\n    }));\r\n  }\r\n\r\n  // Loading not requested by scroll observer: Start immediately\r\n  return insertToDom(article);\r\n};\r\n\r\n/**\r\n * Starts the scroll observer, loading new articles when the end is reached\r\n */\r\nfunction startScrollObserver() {\r\n  // Load article, if observer reports a change & article is visible\r\n  const handleIntersection = entries => {\r\n    entries.forEach(entry => {\r\n      const article = findArticle(entry.target.id);\r\n      // Update \"inViewport\" property to reflect visibility status\r\n      article.inViewport = entry.isIntersecting;\r\n\r\n      if (article.inViewport) {\r\n        // Load the article\r\n        loadArticleIfNeeded(article, { fromObserver: true }).then(() => {\r\n          // Try retrieving the article's title if it isn't there already\r\n          if (!article.title) {\r\n            const titleEl = article.element.querySelector('h1');\r\n            const title = titleEl && `${titleEl.textContent} – sleak`;\r\n            article.title = title;\r\n          }\r\n          // Update hash, so URL links directly to current article\r\n          updateHash(article.name, article.title);\r\n        });\r\n      } else {\r\n        const visibleArticle = articles.find(({ inViewport }) => inViewport);\r\n        // No single article visible? Reset\r\n        if (!visibleArticle) updateHash('', 'sleak – design magazine');\r\n        // Else: Set hash to (still) visible article\r\n        else updateHash(visibleArticle.name, visibleArticle.title);\r\n      }\r\n    });\r\n  };\r\n\r\n  // Observe all articles to watch when they become visible\r\n  const options = { rootMargin: '-1px 0px' };\r\n  const articleObserver = new IntersectionObserver(handleIntersection, options);\r\n  articles.forEach(({ element }) => articleObserver.observe(element));\r\n}\r\n\r\n/**\r\n * Main function to load an article.\r\n * Loads the article and all articles preceding it.\r\n * @param {string|number} target Name or index (zero-based) of the article\r\n */\r\nasync function loadArticle(target) {\r\n  const targetArticle = findArticle(target);\r\n  if (!targetArticle) return;\r\n\r\n  // Load article + articles preceding it (index lesser than/equal to target)\r\n  const articlesToLoad = articles\r\n    .filter((_, index) => index <= targetArticle.index)\r\n    .map(loadArticleIfNeeded);\r\n\r\n  try {\r\n    // Wait, until all articles are loaded\r\n    await Promise.all(articlesToLoad);\r\n  } catch (error) {\r\n    return console.error(\r\n      `Fehler beim Laden des Artikels ${targetArticle.name}: ${error}`,\r\n    );\r\n  }\r\n\r\n  return targetArticle;\r\n}\r\n\r\nexport { startScrollObserver, loadArticle, articles };\r\nexport default loadArticle;\r\n","import { $, debounce, isCrawler } from './utils';\r\nimport {\r\n  startScrollObserver,\r\n  loadArticle,\r\n  articles,\r\n} from './utils/load-article';\r\n\r\nasync function init() {\r\n  // Check if device has a touch interface to adjust hint on splash screen\r\n  // ('click to continue' / 'tap screen to continue')\r\n  const deviceSupportsTouch = Boolean(\r\n    'ontouchstart' in window ||\r\n      window.navigator.maxTouchPoints > 0 ||\r\n      window.navigator.msMaxTouchPoints > 0 ||\r\n      (window.DocumentTouch && document instanceof DocumentTouch),\r\n  );\r\n  if (deviceSupportsTouch) document.body.classList.add('supports-touch');\r\n\r\n  // Manually calculate mobile viewport size, see:\r\n  // https://css-tricks.com/the-trick-to-viewport-units-on-mobile/\r\n  const updateWindowHeight = () => {\r\n    const vh = window.innerHeight * 0.01;\r\n    document.documentElement.style.setProperty('--vh', `${vh}px`);\r\n  };\r\n  updateWindowHeight();\r\n  window.addEventListener('resize', debounce(updateWindowHeight, 500));\r\n\r\n  // HTML elements\r\n  const splash = $('.js-splash');\r\n  const main = $('.js-main');\r\n\r\n  // Scroll down to first article when clicking/tapping the splash screen\r\n  splash.addEventListener('click', () => {\r\n    main.scrollIntoView({ behavior: 'smooth', block: 'start' });\r\n  });\r\n\r\n  const { hash } = window.location;\r\n  const targetId = hash.slice(1);\r\n  // Try loading the article specified in the hash\r\n  const targetArticle = await loadArticle(targetId);\r\n  // No (valid) article? Just load the first one\r\n  if (!targetArticle) await loadArticle(0);\r\n\r\n  // Crawler? Load all articles, at least those running JS get all markup (SEO)\r\n  if (isCrawler) await loadArticle(articles.length - 1);\r\n\r\n  // Update page to allow scrolling and adjust styling\r\n  document.body.classList.remove('empty');\r\n  // Start observer, so further articles are loaded upon reaching the end\r\n  startScrollObserver();\r\n\r\n  // Update sticky header, which has to be repositioned now that an article\r\n  // has been loaded and the window is scrollable\r\n  window.Stickyfill.refreshAll(); // ! see utils/polyfills.js\r\n\r\n  // If there was a specific article targeted in the URL hash: scroll to it\r\n  if (targetArticle) {\r\n    targetArticle.element.scrollIntoView({\r\n      behavior: 'smooth',\r\n      block: 'start',\r\n    });\r\n  }\r\n\r\n  // Listen for further hash changes\r\n  window.addEventListener('hashchange', async () => {\r\n    const { hash } = window.location;\r\n    const targetId = hash.slice(1);\r\n    const target = document.getElementById(targetId);\r\n    if (target && target.getAttribute('data-loaded') === 'false') {\r\n      const article = await loadArticle(targetId);\r\n      if (!article) return;\r\n      article.element.scrollIntoView({ behavior: 'smooth', block: 'start' });\r\n    }\r\n  });\r\n}\r\n\r\n// Go!\r\nwindow.onload = init;\r\n"]}