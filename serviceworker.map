{"version":3,"sources":["serviceworker.js"],"names":["CACHE_NAME","staticAssets","self","addEventListener","event","waitUntil","caches","open","then","cache","fetch","response","json","assets","hashedAssets","Object","entries","filter","sourceURL","endsWith","map","hashedURL","addAll","skipWaiting","allowedCaches","keys","cacheNames","cacheDeletePromises","cacheName","includes","delete","Promise","all","checkResponseStatus","r","res","rej","status","statusText","isRequestCacheable","request","url","URL","protocol","isResponseCacheable","type","requestFailingWith404","catch","body","JSON","stringify","error","Response","headers","requestThenCache","put","clone","match","requestURL","Request","substring","indexOf","respondWith","navigator","onLine"],"mappings":"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","file":"serviceworker.map","sourceRoot":"..","sourcesContent":["const CACHE_NAME = 'sleak-v3';\r\n\r\nconst staticAssets = [\r\n  '.',\r\n  './articles/antarktis.html',\r\n  './articles/apollo.html',\r\n  './articles/bertram.html',\r\n  './articles/graffiti.html',\r\n  './articles/ki.html',\r\n  './articles/kunst.html',\r\n  './articles/medien.html',\r\n  './articles/melanka.html',\r\n  './articles/nachbar.html',\r\n  './articles/oesterreich.html',\r\n  './articles/seemann.html',\r\n];\r\n\r\n// get the filenames to cache from the parcel-manifest and add them to cache\r\nself.addEventListener('install', event => {\r\n  event.waitUntil(\r\n    caches\r\n      .open(CACHE_NAME)\r\n      .then(cache =>\r\n        fetch('./parcel-manifest.json')\r\n          .then(response => response.json())\r\n          .then(assets => {\r\n            const hashedAssets = Object.entries(assets)\r\n              // filter out files that are unnecessary to cache\r\n              .filter(\r\n                ([sourceURL]) =>\r\n                  !sourceURL.endsWith('.map') &&\r\n                  !sourceURL.endsWith('.webmanifest'),\r\n              )\r\n              .map(([_, hashedURL]) => hashedURL);\r\n\r\n            return cache.addAll([...staticAssets, ...hashedAssets]);\r\n          }),\r\n      )\r\n      .then(() => self.skipWaiting()),\r\n  );\r\n});\r\n\r\n/* delete old caches on activation */\r\nself.addEventListener('activate', event => {\r\n  const allowedCaches = [CACHE_NAME];\r\n  event.waitUntil(\r\n    caches.keys().then(cacheNames => {\r\n      const cacheDeletePromises = cacheNames.map(cacheName => {\r\n        if (!allowedCaches.includes(cacheName)) {\r\n          return caches.delete(cacheName);\r\n        }\r\n      });\r\n      return Promise.all(cacheDeletePromises);\r\n    }),\r\n  );\r\n});\r\n\r\nconst checkResponseStatus = r =>\r\n  new Promise((res, rej) => {\r\n    if ((r.status >= 200 && r.status < 300) || r.status === 0) res(r);\r\n    else rej(r.statusText);\r\n  });\r\n/* Helper functions to determine whether requests/responses should be cached */\r\nconst isRequestCacheable = request => {\r\n  const url = new URL(request.url);\r\n  if (url.protocol === 'chrome-extension:') return false;\r\n\r\n  return true;\r\n};\r\nconst isResponseCacheable = response => {\r\n  // don't cache opaque response to prevent exceeding cache size quota\r\n  // see https://cloudfour.com/thinks/when-7-kb-equals-7-mb/\r\n  if (response.status === 0 || response.type === 'opaque') return false;\r\n\r\n  return true;\r\n};\r\n\r\nconst requestFailingWith404 = event => {\r\n  return fetch(event.request).catch(() => {\r\n    const body = JSON.stringify({\r\n      error:\r\n        \"Sorry, you're offline. Try again once you have a working internet connection.\",\r\n    });\r\n    const headers = { 'Content-Type': 'application/json' };\r\n    return new Response(body, {\r\n      status: 404,\r\n      statusText: 'Not Found',\r\n      headers,\r\n    });\r\n  });\r\n};\r\nconst requestThenCache = (event, cache) => {\r\n  return fetch(event.request)\r\n    .then(checkResponseStatus)\r\n    .then(response => {\r\n      if (isResponseCacheable(response)) {\r\n        cache.put(event.request, response.clone());\r\n      }\r\n      return response;\r\n    })\r\n    .catch(() => cache.match(event.request));\r\n};\r\n\r\nself.addEventListener('fetch', event => {\r\n  // if request should not be cached: respond with normal 404 fetch and return\r\n  if (!isRequestCacheable(event.request)) {\r\n    event.respondWith(requestFailingWith404(event));\r\n    return;\r\n  }\r\n\r\n  // ! ignore query strings\r\n  const requestURL = event.request.url;\r\n  const request = requestURL.includes('?')\r\n    ? new Request(requestURL.substring(requestURL.indexOf('?') + 1))\r\n    : event.request;\r\n\r\n  event.respondWith(\r\n    caches\r\n      .match(request)\r\n      .then(checkResponseStatus)\r\n      .then(response => {\r\n        return caches.open(CACHE_NAME).then(cache => {\r\n          if (navigator.onLine) requestThenCache(event, cache);\r\n          return response;\r\n        });\r\n      })\r\n      .catch(() =>\r\n        caches.open(CACHE_NAME).then(cache => requestThenCache(event, cache)),\r\n      ),\r\n  );\r\n});\r\n"]}